<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Eco Builder - Build Your Ecosystem</title>
    <style>
        body {
            margin: 0;
            font-family: Arial, sans-serif;
            background-color: #f0f8f0;
            color: #333;
            padding: 0;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            text-align: center;
            padding: 20px;
        }

        h1 {
            font-size: 32px;
            color: #228B22;
        }

        p {
            font-size: 16px;
            margin-bottom: 20px;
        }

        #gameCanvas {
            border: 2px solid #228B22;
            background-color: #e0f7e0;
            display: block;
            margin: 20px auto;
        }

        .toolbar {
            display: flex;
            justify-content: center;
            gap: 10px;
            flex-wrap: wrap;
            margin: 20px 0;
        }

        .tool-btn {
            background-color: #228B22;
            color: white;
            border: none;
            padding: 10px 15px;
            cursor: pointer;
            border-radius: 5px;
            font-size: 14px;
        }

        .tool-btn:hover {
            background-color: #1a6e1a;
        }

        .tool-btn.selected {
            background-color: #145214;
        }

        .score, .timer {
            font-size: 18px;
            padding: 10px;
            background-color: #90EE90;
            border-radius: 5px;
            margin: 10px;
        }

        .instructions {
            font-size: 14px;
            max-width: 600px;
            margin: 20px auto;
            background-color: #fff;
            padding: 15px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            h1 {
                font-size: 24px;
            }

            .toolbar {
                flex-direction: column;
                align-items: center;
            }

            .tool-btn {
                width: 80%;
                margin: 5px 0;
            }

            .instructions {
                font-size: 12px;
            }

            .score, .timer {
                font-size: 16px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Eco Builder</h1>
        <p>Build and maintain a balanced ecosystem! Earn sustainability points before the 60-second timer runs out.</p>
        <canvas id="gameCanvas"></canvas>
        <div class="toolbar">
            <button class="tool-btn" data-tool="tree">Plant Tree</button>
            <button class="tool-btn" data-tool="water">Add Water</button>
            <button class="tool-btn" data-tool="rabbit">Add Rabbit</button>
            <button class="tool-btn" data-tool="fox">Add Fox</button>
            <button class="tool-btn" data-tool="remove">Remove Item</button>
            <div class="score">Sustainability Points: <span id="score">0</span></div>
            <div class="timer">Time Left: <span id="timer">00:60</span></div>
        </div>
        <div class="instructions">
            <h3>How to Play</h3>
            <p>Click to place trees, water, rabbits, or foxes on the grid. Balance is key‚Äîtoo many animals or not enough resources cause problems! Watch for droughts or overpopulation. Use 'Remove Item' to clear elements. Achieve the highest score in 60 seconds!</p>
        </div>
    </div>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');
        const timerElement = document.getElementById('timer');

        const GRID_SIZE = 20;
        let CELL_SIZE;
        let grid = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(null));
        let selectedTool = null;
        let score = 0;
        let droughtTimer = 0;
        let populationCheck = 0;
        let gameTime = 60;
        let timerInterval;

        const tools = {
            tree: { color: '#228B22', symbol: 'üå≥', resource: true },
            water: { color: '#00CED1', symbol: 'üíß', resource: true },
            rabbit: { color: '#FFA500', symbol: 'üê∞', population: 1 },
            fox: { color: '#FF4500', symbol: 'ü¶ä', population: 2 }
        };

        function resizeCanvas() {
            const maxSize = Math.min(window.innerWidth, window.innerHeight) - 40;
            CELL_SIZE = Math.floor(maxSize / GRID_SIZE);
            canvas.width = GRID_SIZE * CELL_SIZE;
            canvas.height = GRID_SIZE * CELL_SIZE;
            canvas.style.width = `${GRID_SIZE * CELL_SIZE}px`;
            canvas.style.height = `${GRID_SIZE * CELL_SIZE}px`;
            render();
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        function updateTimer() {
            if (gameTime <= 0) {
                clearInterval(timerInterval);
                alert(`Time's up! Final Score: ${score}. Try again to beat your score!`);
                return;
            }
            gameTime--;
            const minutes = Math.floor(gameTime / 60);
            const seconds = gameTime % 60;
            timerElement.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        function startTimer() {
            timerInterval = setInterval(updateTimer, 1000);
        }

        canvas.addEventListener('click', (event) => {
            const rect = canvas.getBoundingClientRect();
            const x = Math.floor((event.clientX - rect.left) / CELL_SIZE);
            const y = Math.floor((event.clientY - rect.top) / CELL_SIZE);

            if (x >= 0 && x < GRID_SIZE && y >= 0 && y < GRID_SIZE) {
                if (selectedTool === 'remove') {
                    if (grid[y][x]) {
                        grid[y][x] = null;
                        updateScore(-2);
                        render();
                    }
                } else if (selectedTool && grid[y][x] === null) {
                    const item = { ...tools[selectedTool], count: 1 };
                    grid[y][x] = item;
                    updateScore(5);
                    render();
                }
            }
        });

        document.querySelectorAll('.tool-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                selectedTool = btn.dataset.tool;
                document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('selected'));
                btn.classList.add('selected');
            });
        });

        function consumeResource(amount) {
            for (let i = 0; i < amount; i++) {
                const resCells = [];
                for (let y = 0; y < GRID_SIZE; y++) {
                    for (let x = 0; x < GRID_SIZE; x++) {
                        if (grid[y][x] && grid[y][x].resource && grid[y][x].count > 0) {
                            resCells.push({ x, y });
                        }
                    }
                }
                if (resCells.length === 0) return;
                const idx = Math.floor(Math.random() * resCells.length);
                const pos = resCells[idx];
                grid[pos.y][pos.x].count--;
                if (grid[pos.y][pos.x].count <= 0) {
                    grid[pos.y][pos.x] = null;
                }
            }
        }

        function consumeRabbit(amount) {
            for (let i = 0; i < amount; i++) {
                const rabCells = [];
                for (let y = 0; y < GRID_SIZE; y++) {
                    for (let x = 0; x < GRID_SIZE; x++) {
                        if (grid[y][x] && grid[y][x].population === 1 && grid[y][x].count > 0) {
                            rabCells.push({ x, y });
                        }
                    }
                }
                if (rabCells.length === 0) return;
                const idx = Math.floor(Math.random() * rabCells.length);
                const pos = rabCells[idx];
                grid[pos.y][pos.x].count--;
                if (grid[pos.y][pos.x].count <= 0) {
                    grid[pos.y][pos.x] = null;
                }
            }
        }

        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const fontSize = Math.max(10, Math.floor(CELL_SIZE / 2));
            ctx.font = `${fontSize}px Arial`;
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    if (grid[y][x]) {
                        ctx.fillStyle = grid[y][x].color;
                        ctx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE - 1, CELL_SIZE - 1);
                        ctx.fillStyle = '#000';
                        ctx.fillText(grid[y][x].symbol, x * CELL_SIZE + (CELL_SIZE - fontSize) / 2, y * CELL_SIZE + CELL_SIZE / 2);
                        ctx.fillText(grid[y][x].count, x * CELL_SIZE + (CELL_SIZE - fontSize) / 2, y * CELL_SIZE + CELL_SIZE - 2);
                    }
                }
            }
        }

        function updateEcosystem() {
            let totalResources = 0;
            let rabbits = 0;
            let foxes = 0;

            // Count current state
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const cell = grid[y][x];
                    if (cell) {
                        if (cell.resource) totalResources += cell.count;
                        if (cell.population === 1) rabbits += cell.count;
                        if (cell.population === 2) foxes += cell.count;
                    }
                }
            }

            // Simulate ecosystem dynamics
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const cell = grid[y][x];
                    if (cell) {
                        if (cell.resource) {
                            cell.count = Math.min(cell.count + 1, 5); // Resources grow
                        } else if (cell.population === 1) { // Rabbits
                            if (Math.random() < 0.3) {
                                if (totalResources > 0) {
                                    consumeResource(1);
                                    cell.count++;
                                }
                            }
                        } else if (cell.population === 2) { // Foxes
                            if (Math.random() < 0.4) {
                                if (rabbits > 0) {
                                    consumeRabbit(1);
                                    cell.count++;
                                }
                            }
                            if (rabbits < 2) {
                                cell.count = Math.max(0, cell.count - 1);
                            }
                        }
                    }
                }
            }

            // Drought or overpopulation check
            droughtTimer++;
            if (droughtTimer > 60 && Math.random() < 0.1) {
                consumeResource(2);
                updateScore(-10);
                droughtTimer = 0;
            }
            populationCheck++;
            if (populationCheck > 100 && (rabbits > totalResources || foxes > rabbits / 2)) {
                updateScore(-15);
                populationCheck = 0;
            }

            render();
        }

        function updateScore(points) {
            score += points;
            scoreElement.textContent = score;
            if (score < 0) {
                clearInterval(timerInterval);
                alert(`Game Over! Ecosystem unbalanced. Time Left: ${timerElement.textContent}, Score: ${score}. Try again!`);
                gameTime = 0; // Stop the game
            }
        }

        setInterval(updateEcosystem, 1000);
        startTimer();
        render();
    </script>
</body>
</html>